---
description: UI/UX Design System Rules (Cognitive Load, Typography, Color, Grid, Interaction, IA)
globs:
  - "**/*.{ts,tsx,js,jsx}"
  - "**/*.{css,scss}"
  - "**/*.{md,mdx}"
alwaysApply: true
---

# UI/UX Core Rules

## 1 Core Principles

- **Minimize cognitive load (Occam’s Razor)**  
  Prefer the simplest design that achieves the same outcome. Avoid cleverness that increases user thinking cost.

- **Remove extraneous cognitive load**  
  Do not add unnecessary visual stimulation, decoration, or multiple choices that are not required for task completion.

- **Recognition over recall**  
  Design flows so users can _recognize_ actions from cues instead of having to _remember_ what to do.

  - Prefer visible labels, previews, examples, defaults, and contextual hints.

- **Doherty Threshold**  
  Aim for system feedback/response time **≤ 0.4s** for primary interactions whenever feasible.
  - If > 0.4s is unavoidable, immediately show feedback (optimistic UI, skeleton, spinner, progress).

## 2 Typography & Hierarchy

- **Text-first design**  
  Assume typography drives most of the UI experience; prioritize readability and legibility above decoration.

- **Anchor size (Body baseline)**  
  Default body text to **16pt**. Use it as the baseline for spacing and type scales unless there is a clear reason to deviate.

- **Build hierarchy in this order**  
  Users perceive importance strongest by: **color > size > shape**.

  - Establish hierarchy with **weight (boldness)** and **color** first.
  - Adjust **size** only when necessary.

- **Line-height & letter-spacing**
  - Body line-height recommendation: **fontSize × 1.6**
  - For 16–17pt body text: apply letter-spacing **-0.3** (or **-1%**) as default.

## 3 Color & Accessibility

- **Design with luminance first**  
  Define UI form using **value/brightness**. Use saturation sparingly and only for the most important elements.

- **Contrast compliance (WCAG)**  
  Ensure at least **AA contrast (≥ 4.5:1)** for text and essential UI components.

- **Semantic color consistency**

  - Green: success
  - Red: error / danger
  - Yellow: warning
  - Blue: info / link  
    Apply these meanings consistently across the product.

- **Natural tint/shade behavior**
  - For **tints (lighter)**: reduce saturation to avoid neon/pastel glare
  - For **shades (darker)**: increase saturation slightly to preserve vividness

## 4 Layout & Grid

- **Grid unit**  
  Use an **8pt / 4pt** spacing system as the baseline.

- **Columns**

  - Mobile: **4-column** grid
  - Desktop: **12-column** grid

- **Margin & padding definition**

  - Define spacing in clockwise order: **top, right, bottom, left**
  - Apply proximity: place related items closer; separate unrelated groups clearly.

- **Responsive breakpoints**
  - Define breakpoints for **mobile / tablet / desktop**
  - At smaller widths, **reduce visible content density** (fewer items, fewer options) to improve scanning and navigation.

## 5 Interaction Components

- **Interaction pipeline**
  Every interaction must follow:  
  **Input → Process → Output → Feedback**  
  Always communicate state changes immediately.

- **Button design**

  - Buttons must clearly look “pressable” (color, underline, elevation, etc.)
  - Label with an explicit **verb phrase** describing the outcome (e.g., “Save changes”, “Create post”)

- **Text fields**

  - Mark required fields clearly (e.g., red asterisk `*`)
  - Provide the appropriate virtual keyboard/input mode (email, numeric, etc.) during entry

- **Progress indicators**
  - Short tasks: looping animation (spinner/skeleton)
  - Long tasks: show progress via **%** or **step count** to manage waiting perception

## 6 IA & Navigation

- **Choose the right structure**
  Pick based on information nature:

  - Flat
  - Tree (hierarchical)
  - Network (graph-like)

- **Tabs**
  Use tabs only to split content of the **same hierarchy level**.  
  The active tab must be visually unmistakable.

- **Bottom sheets**
  Use when interaction is more complex than a simple dialog.  
  Apply background **dim** to focus attention on the sheet.

## 7 Skeleton Loading (Perceived Performance)

- **When to use skeletons**

  - Use skeleton loading for **content layouts that are predictable** (lists, cards, feeds, tables, forms).
  - Prefer skeletons over spinners when users expect **structured content** to appear.

- **Shape should match final UI**

  - Skeletons must mirror the final layout: same spacing, alignment, and approximate line lengths.
  - Avoid generic blocks that don’t resemble the actual content.

- **Avoid layout shift**

  - Reserve space to match final component height/width as closely as possible to prevent jank.
  - Keep skeleton dimensions stable across breakpoints.

- **Timing rules**

  - If response is likely **< 0.4s**, consider showing nothing or a subtle immediate state change (to avoid flicker).
  - For **0.4s ~ 2s**, skeletons are ideal.
  - For **> 2s** or uncertain duration, combine skeleton + explicit progress/step or status text when helpful.

- **Perceived realism**

  - Use subtle motion (shimmer/pulse) but avoid aggressive animation that adds visual noise.
  - Keep contrast low; skeletons should not compete with real content.

- **Accessibility**

  - Mark skeleton containers as non-content for assistive tech (e.g., `aria-busy`, `aria-live` usage as appropriate).
  - Provide meaningful status text for screen readers when loading is long (“Loading results…”).

- **Replace strategy**
  - Replace skeleton with real content **atomically per section** (header, list, footer) to reduce jumpiness.
  - Prefer progressive rendering: show above-the-fold skeletons first, then below-the-fold.
